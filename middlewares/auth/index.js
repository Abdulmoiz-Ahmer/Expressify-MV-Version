import dotenv from 'dotenv';
import jwt from 'jsonwebtoken';
import mongoose from 'mongoose';
import { logger, sendMessage, sendError } from '~/utils';
import { status } from '~/constants';
import { UserSchema } from '~/schemas/User';

dotenv.config();

// eslint-disable-next-line consistent-return
export const auth = async (request, response, next) => {
	//	Codes that we might return coming from status
	const { UNAUTHROIZED, PRE_CONDITION_FAILED, FORBIDDEN } = status;

	// Expecting authorization field in header starting bearer followed by space and token
	if (
		!request.headers.authorization ||
		!request.headers.authorization.toLowerCase().includes('bearer')
	)
		return sendMessage(
			'Access Denied! No Token Provided',
			response,
			UNAUTHROIZED,
		);

	try {
		//	Splitting authorization based on space to get token
		const accessToken = request.headers.authorization.split(' ')[1];

		//	Extracting the payload(data) from token
		const { payload: payLoad } = jwt.decode(accessToken, {
			complete: true,
		});

		//	Making sure token is not expired
		if (new Date(payLoad.exp * 1000) < new Date(Date.now()))
			return sendMessage('Token Expired', response, PRE_CONDITION_FAILED);

		//	Checking the token is generated by us
		const inDataBase = await UserSchema.findOne(
			{
				_id: mongoose.Types.ObjectId(payLoad.user.user_id),
				'tokens.access_token': accessToken,
			},
			{ _id: 1, remember_me: 1, email: 1 },
		);

		// eslint-disable-next-line no-underscore-dangle
		if (!inDataBase || !inDataBase._id)
			return sendMessage('Invalid Token', response, FORBIDDEN);

		//	Extracting user object from the payload for future use in any api call as long as it supports req object
		request.user = payLoad.user;
		next();
	} catch (exception) {
		//	Log in case of any abnormal crash
		logger('error', 'Error:', exception.message);
		return sendError('Invalid Token', response, exception);
	}
};
